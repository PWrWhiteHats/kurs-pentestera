#!/usr/bin/env python3
#
# Stealth scan
# Szukanie otwartych portów bez ustanawiania
# pełnego połączenia TCP
#
from scapy.all import sr, TCP, IP, RandShort
import argparse, netaddr, sys, os


if os.name == 'posix' and os.geteuid() != 0:
    print("Run this as root")
    quit()

# przetwarzanie argumentów wiersza poleceń
parser = argparse.ArgumentParser(description="Stealh port scanner")
parser.epilog = f"example: sudo {sys.argv[0]} --subnet=192.168.0.1 -p100-200"

parser.add_argument("--address", "-a", action="store",
                    required=True, help="IPv4 address to scan")
parser.add_argument("--port-range", "-p", action="store",
                    required=True, help="port range to scan")
parser.add_argument("--verbose", "-v", action='store_true', help="verbosing",
                    default=False)
parser.add_argument("--iface", "-i", action='store', required=True,
                    help="network interface")
parser.add_argument("--timeout", "-t", action="store", help="timeout in seconds",
                    default=2)

args = parser.parse_args()

address, port_range = args.address, args.port_range
verbose, iface = args.verbose, args.iface
timeout = args.timeout


# Walidacja danych
try:
    netaddr.IPAddress(address)
    port_range = tuple(map(int, port_range.split('-')))
    port_range = port_range[0] if len(port_range) == 1 else port_range[:2]
    timeout = int(timeout)
except (netaddr.core.AddrFormatError, ValueError, TypeError) as err:
    print(err)
else:

    # Wysłanie pakietów TCP z flagą SYN na zadane adresy i numery portów
    answers, _ = sr(IP(dst=address)/TCP(sport=RandShort(),dport=port_range,flags="S"),
                    verbose=verbose, iface=iface, timeout=timeout)

    # odfiltrowanie z odpowiedzi portów, które odpowiedziały SYN-ACK
    open_ports = answers.filter(lambda s,r: r.sprintf("%TCP.flags%") == "SA")

    # wypisanie wyników
    open_ports.make_table(lambda s,r: (s.dst, s.dport,r.sprintf("{TCP:%TCP.flags%}")))

import base64

#int()
# Funkcja int jest w także w stanie operować na liczbach innych niż dziesiętnych
h = int("0x13", 16)
o = int("013", 8)
# print(f"{h}, {o}")


# Czym jest iterator?
class MyRange:
    def __init__(self, limit):
        self.limit = limit
        self.value = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.value < self.limit:
            self.value += 1
            return self.value - 1
        else:
            raise StopIteration

# for x in range(100000000000000000000000000000000000000000000):
#     print(x)

# list(range(1000000000000))

# map(funkcja, iterable)
# funkcja map pozwala nam na zmodyfikowanie wszystkich elementów iteratora na raz
# poprzez wykonanie funkcji przekazanej jako pierwszy argument na każdym z elementów
a = ["1", "2", "3", "4", "5"]
m = map(int, a)
l = list(m)
print(l)
# ale co jeśli dostaniemy listę liczb szesnastkowych?
a = ["0x10", "0x11", "0x12", "0x13"]

# nie ma zmiennej, którą moglibyśmy wstawić w miejsce "?", 
# a funkcja map przyjmuje tylko funkcje które mają tylko jeden argument

# lambda
# funkcja to jednolinijkowa anonimowa funkcja, która wykonuje tylko jedno polecenie
hex_to_int = lambda x: int(x, 16)
# hex_to_int("0x10") = 16 
# mamy teraz funkcję która przyjmuje jeden argument, więc możemy użyć jej w map()
l = list(map(hex_to_int, a))
#lub szybciej, bez deklarowania zmiennej hex_to_int:
l = list(map(lambda x: int(x, 16), a))

#list comprehension
potegi = [x**2 for x in range(10)]
parzyste_potegi = [x**2 for x in range(10) if x % 2 == 0]


matrix = [[1, 2, 3], 
          [4, 5, 6], 
          [7, 8, 9]]

list = [num for row in matrix for num in row]


l = [int(x, 16) for x in a] # efekt ten sam jak przy list(map(lambda x: int(x, 16), a))

# base64 to łatwy sposób na kodowanie danych tak, 
# aby dało się je przesłać w formie tekstowej
# działa ono następująco: 
# zapisujemy dane w formie binarnej
# "ABC" -> 010000010100001001000011
# dzielimy na 6-bitowe fragmenty
# 010000010100001001000011 -> 010000 010100 001001 000011
# zamieniamy je na liczby
# 16 20 9 3
# i przypisujemy je do indesksów z tabeli
# QUJD

encoded = base64.b64encode("ABC".encode())
# print(encoded)
decoded = base64.b64decode(encoded)
# print(decoded)